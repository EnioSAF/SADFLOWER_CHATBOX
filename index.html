<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
  <title>SadFlower® — Terminal V1</title>

  <style>
    :root {
      --broadcaster: #ff2a55;
      --mod: #7aa2f7;
      --vip: #ff8f40;
      --sub: #c792ea;
      --time: #2bbac5;
      --text: #cfcfcf;

      --meta-h: 18px;
      --meta-font: 10.5px;
      --chev: 7px;
      --emote-max-h: 3.6em;
      --emote-max-w: 12em;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      width: 100%;
      height: 100%;
      background: transparent;
      font-family: "JetBrains Mono", Tahoma, "MS Sans Serif", Arial, sans-serif;
      font-size: 16.5px;
      overflow: hidden;
    }

    /* WINDOW - Style Windows 98 */
    .window {
      width: 420px;
      height: 725px;
      border: 4px solid #dfdfdf;
      border-bottom-color: #404040;
      border-right-color: #404040;
      border-left-color: #dfdfdf;
      border-top-color: #dfdfdf;
      box-shadow: inset 2px 2px #808080, inset -2px -2px #f0f0f0;
      padding: 2px;
      display: flex;
      flex-direction: column;
    }

    /* TITLE BAR - Style Windows 98 */
    .titlebar {
      background: linear-gradient(90deg, #000080, #1084d0);
      padding: 3px 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: rgb(29, 29, 29);
      font-weight: bold;
      height: 32px;
      flex-shrink: 0;
    }

    .title {
      color: #fff;
      font-size: 14px;
      letter-spacing: .03em;
      padding-left: 20px;
      font-weight: bold;
      flex-grow: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .controls {
      display: flex;
      gap: 2px;
    }

    .ctrl {
      width: 24px;
      height: 20px;
      right: 10px;
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      border: 1px solid #404040;
      border-right-color: #f0f0f0;
      border-bottom-color: #f0f0f0;
      border-left-color: #404040;
      border-top-color: #404040;
      background-color: #c0c0c0;
      box-shadow: inset -1px -1px #808080, inset 1px 1px #f0f0f0;
      font-size: 10px;
      line-height: 1;
      padding: 0;
      user-select: none;
    }

    .ctrl.close {
      background: red;
    }

    /* CHAT */
    .chat {
      flex: 1;
      padding: 14px;
      display: flex;
      flex-direction: column-reverse;
      gap: 12px;
      overflow: hidden;
      border: 4px solid #808080;
      border-bottom-color: #dfdfdf;
      border-right-color: #dfdfdf;
      border-left-color: #404040;
      border-top-color: #404040;
    }

    /* MESSAGE */
    .message {
      padding: 10px 12px;
      border-radius: 2px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.22));
      backdrop-filter: blur(18px) saturate(140%) brightness(1.05);
      -webkit-backdrop-filter: blur(18px) saturate(140%) brightness(1.05);
      border: 1px solid transparent;
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, .18),
        0 2px 6px rgba(0, 0, 0, .35);
      animation: msg-in 220ms steps(3, end);
    }

    .message.reply {
      position: relative;
      padding-left: 16px;
    }

    .message.reply::before {
      content: "";
      position: absolute;
      left: 6px;
      top: 6px;
      bottom: 6px;
      width: 2px;
      background: rgba(255, 255, 255, .4);
    }

    .reply-label {
      font-size: 10px;
      opacity: .7;
      margin-bottom: 2px;
    }

    .reply-box {
      background: #7aa2f72c;
      border: 1px solid rgba(255, 255, 255, 0.18);
      border-left: 4px solid rgba(255, 255, 255, 0.45);
      padding: 6px 8px;
      margin-bottom: 6px;
      font-size: 12px;
      line-height: 1.35;
    }

    .reply-box .reply-user {
      font-weight: 700;
    }

    .reply-box .reply-text {
      color: #cfcfcf;
      opacity: 0.85;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    @keyframes msg-in {
      from {
        opacity: 0;
        transform: translateY(6px);
      }

      to {
        opacity: 1;
        transform: none;
      }
    }

    @keyframes msg-out {
      to {
        opacity: 0;
        transform: scaleY(.6);
      }
    }

    /* EVENT */
    .message.event {
      background: #c0c0c0;
      color: #000;
      border-color: #000;
      box-shadow: inset 1px 1px 0 #fff, inset -1px -1px 0 #404040;
      animation: event-in 300ms steps(4, end);
    }

    @keyframes event-in {
      from {
        opacity: 0;
        transform: scale(.95);
      }

      to {
        opacity: 1;
        transform: none;
      }
    }

    /* META */
    .meta {
      display: flex;
      align-items: center;
      height: var(--meta-h);
      margin-bottom: 4px;
    }

    .seg {
      position: relative;
      height: var(--meta-h);
      display: inline-flex;
      align-items: center;
      padding: 0 8px 0 10px;
      font-size: var(--meta-font);
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: .08em;
      color: #0b0f14;
    }

    .seg::after {
      content: "";
      position: absolute;
      right: calc(-1 * var(--chev) + 1px);
      top: 0;
      width: 0;
      height: 0;
      border-top: calc(var(--meta-h)/2) solid transparent;
      border-bottom: calc(var(--meta-h)/2) solid transparent;
      border-left: var(--chev) solid;
    }

    .seg.broadcaster {
      background: var(--broadcaster);
    }

    .seg.broadcaster::after {
      border-left-color: var(--broadcaster);
    }

    .seg.mod {
      background: var(--mod);
    }

    .seg.mod::after {
      border-left-color: var(--mod);
    }

    .seg.vip {
      background: var(--vip);
    }

    .seg.vip::after {
      border-left-color: var(--vip);
    }

    .seg.sub {
      background: var(--sub);
    }

    .seg.sub::after {
      border-left-color: var(--sub);
    }

    .seg.time {
      margin-left: auto;
      background: var(--time);
    }

    .seg.time::after {
      border-left-color: var(--time);
    }

    /* CONTENT */
    .content {
      line-height: 1.6;
      color: var(--text);
      word-wrap: anywhere;
      font-size: 17.5px;
      font-weight: 500;
    }

    .user {
      font-weight: 600;
      margin-right: 6px;
      text-shadow: 0 1px 1px rgba(0, 0, 0, .55);
    }

    .emote {
      height: auto;
      width: auto;
      max-height: var(--emote-max-h);
      max-width: var(--emote-max-w);
      display: block;
    }

    .emote-wrap {
      position: relative;
      display: inline-block;
      vertical-align: -0.25em;
      line-height: 0;
    }

    .emote.overlay {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      max-width: 100%;
      max-height: 100%;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <div class="window">
    <div class="titlebar">
      <div class="title">SADFLOWER — LIVE CHAT</div>
      <div class="controls">
        <div class="ctrl min">_</div>
        <div class="ctrl max">□</div>
        <div class="ctrl close">×</div>
      </div>
    </div>
    <div class="chat" id="chat"></div>
  </div>

  <script src="./tmi.min.js"></script>
  <script>
    (() => {

      const CONFIG = {
        channel: 'EnioSadFlower',
        maxMessages: 8,
        lifeMs: 45000,
        ignore: ['streamelements', 'nightbot', 'streamlabs', 'franksadflower', 'pokemoncommunitygame'],
        ignoreMessages: [
          { user: 'eniosadflower', startsWith: 'Bien ouej' }
        ]
      };
      const chat = document.getElementById('chat');
      const userColorMap = new Map();
      const emoteMap = new Map();

      const esc = s => {
        const d = document.createElement('div');
        d.textContent = s;
        return d.innerHTML;
      };

      const now = () =>
        new Date().toLocaleTimeString('fr-FR', {
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        });

      function hexToRgba(hex, alpha) {
        if (!hex || !hex.startsWith('#')) return `rgba(255,255,255,${alpha})`;
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      }

      function pickFfzUrl(emote) {
        const animated = emote?.animated;
        const animatedUrls = animated && typeof animated === 'object'
          ? (animated.urls || animated)
          : null;
        const urls = animatedUrls || emote?.urls || {};
        const url = urls['4'] || urls['2'] || urls['1'] || null;
        if (!url) return null;
        return url.startsWith('//') ? `https:${url}` : url;
      }

      function pick7tvUrl(emote, scale) {
        const host = emote?.data?.host;
        const files = host?.files || [];
        const pick = name => files.some(f => f.name === name) ? name : null;
        const name =
          pick(`${scale}x.gif`)
          || pick(`${scale}x.webp`)
          || pick('1x.gif')
          || pick('1x.webp')
          || files[0]?.name;
        return host?.url && name ? `${host.url}/${name}` : null;
      }

      async function resolveTwitchId(channel) {
        try {
          const res = await fetch(`https://api.ivr.fi/v2/twitch/user?login=${encodeURIComponent(channel)}`);
          if (!res.ok) return null;
          const data = await res.json();
          const user = Array.isArray(data) ? data[0] : data;
          return user?.id ? String(user.id) : null;
        } catch {
          return null;
        }
      }

      function isZeroWidth7tv(emote) {
        const flags = emote?.data?.flags ?? emote?.flags ?? 0;
        return (flags & 256) === 256;
      }

      async function loadEmotes(channel) {
        const bttvGlobal = await fetch('https://api.betterttv.net/3/cached/emotes/global')
          .then(r => r.json())
          .catch(() => []);
        bttvGlobal.forEach(e => {
          const ext = e.imageType === 'gif' ? 'gif' : 'png';
          emoteMap.set(e.code, { url: `https://cdn.betterttv.net/emote/${e.id}/2x.${ext}`, zeroWidth: false });
        });

        const twitchId = await resolveTwitchId(channel);
        const bttvChan = twitchId
          ? await fetch(`https://api.betterttv.net/3/cached/users/twitch/${twitchId}`).then(r => r.json()).catch(() => null)
          : null;
        bttvChan?.channelEmotes?.forEach(e => {
          const ext = e.imageType === 'gif' ? 'gif' : 'png';
          emoteMap.set(e.code, { url: `https://cdn.betterttv.net/emote/${e.id}/2x.${ext}`, zeroWidth: false });
        });
        bttvChan?.sharedEmotes?.forEach(e => {
          const ext = e.imageType === 'gif' ? 'gif' : 'png';
          emoteMap.set(e.code, { url: `https://cdn.betterttv.net/emote/${e.id}/2x.${ext}`, zeroWidth: false });
        });

        const sevenGlobal = await fetch('https://7tv.io/v3/emote-sets/global')
          .then(r => r.json())
          .catch(() => null);
        sevenGlobal?.emotes?.forEach(e => {
          const url = pick7tvUrl(e, 2);
          if (url) emoteMap.set(e.name, { url, zeroWidth: isZeroWidth7tv(e) });
        });

        const sevenUser = twitchId
          ? await fetch(`https://7tv.io/v3/users/twitch/${twitchId}`).then(r => r.json()).catch(() => null)
          : null;
        sevenUser?.emote_set?.emotes?.forEach(e => {
          const url = pick7tvUrl(e, 2);
          if (url) emoteMap.set(e.name, { url, zeroWidth: isZeroWidth7tv(e) });
        });

        const ffzGlobal = await fetch('https://api.frankerfacez.com/v1/set/global')
          .then(r => r.json())
          .catch(() => null);
        Object.values(ffzGlobal?.sets || {}).forEach(set => {
          set.emoticons?.forEach(e => {
            const url = pickFfzUrl(e);
            if (url) emoteMap.set(e.name, { url, zeroWidth: false });
          });
        });

        const ffzRoom = await fetch(`https://api.frankerfacez.com/v1/room/${encodeURIComponent(channel.toLowerCase())}`)
          .then(r => r.json())
          .catch(() => null);
        const ffzSet = ffzRoom?.sets?.[ffzRoom?.room?.set];
        ffzSet?.emoticons?.forEach(e => {
          const url = pickFfzUrl(e);
          if (url) emoteMap.set(e.name, { url, zeroWidth: false });
        });
      }

      function tokenizeTwitchEmotes(text, emotes) {
        if (!emotes) return [{ type: 'text', value: text }];
        const chars = [...text];
        const map = [];
        for (const id in emotes) {
          emotes[id].forEach(r => {
            const [a, b] = r.split('-').map(Number);
            map.push({ a, b, id });
          });
        }
        map.sort((a, b) => a.a - b.a);
        const tokens = [];
        let last = 0;
        map.forEach(e => {
          if (e.a > last) {
            tokens.push({ type: 'text', value: chars.slice(last, e.a).join('') });
          }
          tokens.push({
            type: 'emote',
            provider: 'twitch',
            staticUrl: `https://static-cdn.jtvnw.net/emoticons/v2/${e.id}/default/dark/2.0`,
            animatedUrl: `https://static-cdn.jtvnw.net/emoticons/v2/${e.id}/animated/dark/2.0`,
            zeroWidth: false
          });
          last = e.b + 1;
        });
        if (last < chars.length) {
          tokens.push({ type: 'text', value: chars.slice(last).join('') });
        }
        return tokens;
      }

      function tokenizeThirdPartyEmotes(tokens) {
        const out = [];
        const wordRegex = /[A-Za-z0-9_]+/g;

        tokens.forEach(token => {
          if (token.type !== 'text') {
            out.push(token);
            return;
          }
          const text = token.value;
          let lastIndex = 0;
          let match;
          wordRegex.lastIndex = 0;
          while ((match = wordRegex.exec(text)) !== null) {
            const start = match.index;
            const word = match[0];
            if (start > lastIndex) {
              out.push({ type: 'text', value: text.slice(lastIndex, start) });
            }
            const meta = emoteMap.get(word);
            if (meta) {
              out.push({ type: 'emote', provider: 'third', url: meta.url, zeroWidth: meta.zeroWidth });
            } else {
              out.push({ type: 'text', value: word });
            }
            lastIndex = start + word.length;
          }
          if (lastIndex < text.length) {
            out.push({ type: 'text', value: text.slice(lastIndex) });
          }
        });

        return out;
      }

      function renderEmoteToken(token, isOverlay) {
        const cls = `emote${isOverlay ? ' overlay' : ''}`;
        if (token.provider === 'twitch') {
          return `<img class="${cls}" src="${token.animatedUrl}" onerror="this.onerror=null;this.src='${token.staticUrl}'">`;
        }
        return `<img class="${cls}" src="${token.url}">`;
      }

      function renderTokens(tokens) {
        const items = [];

        tokens.forEach(token => {
          if (token.type !== 'emote') {
            items.push({ type: 'text', value: token.value });
            return;
          }

          if (token.zeroWidth) {
            const last = items[items.length - 1];
            const prev = items[items.length - 2];
            if (last?.type === 'emote-stack') {
              last.overlays.push(token);
              return;
            }
            if (last?.type === 'text' && /^\s+$/.test(last.value) && prev?.type === 'emote-stack') {
              items.pop();
              prev.overlays.push(token);
              return;
            }
          }

          items.push({ type: 'emote-stack', base: token, overlays: [] });
        });

        return items.map(item => {
          if (item.type === 'text') return esc(item.value);
          const overlays = item.overlays.map(o => renderEmoteToken(o, true)).join('');
          return `<span class="emote-wrap">${renderEmoteToken(item.base, false)}${overlays}</span>`;
        }).join('');
      }

      function colorMentions(html) {
        return html.replace(/@([A-Za-z0-9_]{3,25})/g, (m, n) => {
          const c = userColorMap.get(n.toLowerCase());
          return c ? `<span style="color:${c};font-weight:600">@${n}</span>` : m;
        });
      }

      function buildMessage({ user, color, html, roles, reply }) {
        const msg = document.createElement('div');
        msg.className = 'message';
        msg.style.borderColor = hexToRgba(color, 0.3);

        if (reply) {
          const replyBox = document.createElement('div');
          replyBox.className = 'reply-box';

          const replyUserColor =
            reply.color
            || userColorMap.get(reply.user.toLowerCase())
            || '#c792ea';

          replyBox.innerHTML = `
    <div class="reply-user" style="color:${replyUserColor}">
      ↪ Réponse à ${esc(reply.user)}
    </div>
    <div class="reply-text">
      ${esc(reply.text)}
    </div>
  `;

          msg.appendChild(replyBox);
        }
        const meta = document.createElement('div');
        meta.className = 'meta';

        if (roles.broadcaster) meta.innerHTML += `<div class="seg broadcaster">LIVE</div>`;
        if (roles.mod) meta.innerHTML += `<div class="seg mod">MOD</div>`;
        if (roles.vip) meta.innerHTML += `<div class="seg vip">VIP</div>`;
        if (roles.sub) meta.innerHTML += `<div class="seg sub">SUB</div>`;
        meta.innerHTML += `<div class="seg time">${now()}</div>`;

        const content = document.createElement('div');
        content.className = 'content';

        content.innerHTML = `<span class="user" style="color:${color}">${esc(user)}</span>: ${html}`;

        msg.append(meta, content);

        setTimeout(() => msg.style.animation = 'msg-out 180ms forwards', CONFIG.lifeMs - 200);
        setTimeout(() => msg.remove(), CONFIG.lifeMs);

        return msg;
      }

      function parseRoles(tags) {
        return {
          broadcaster: !!tags.badges?.broadcaster,
          mod: !!(tags.badges?.moderator || tags.mod),
          vip: !!tags.badges?.vip,
          sub: !!(tags.badges?.subscriber || tags.subscriber)
        };
      }

      loadEmotes(CONFIG.channel);

      const client = new tmi.Client({
        connection: { secure: true, reconnect: true },
        channels: ['#' + CONFIG.channel.toLowerCase()]
      });

      client.on('message', (c, t, m, self) => {

        if (self) return;
        const login = t.username.toLowerCase();
        if (CONFIG.ignore.includes(login)) return;
        if (CONFIG.ignoreMessages.some(r => r.user === login && m.startsWith(r.startsWith))) return;

        if (m.startsWith('!')) return;
        const display = t['display-name'] || login;
        const color = t.color || '#9cdcfe';
        userColorMap.set(display.toLowerCase(), color);

        let tokens = tokenizeTwitchEmotes(m, t.emotes);
        tokens = tokenizeThirdPartyEmotes(tokens);
        let html = renderTokens(tokens);
        html = colorMentions(html);

        const replyData = t['reply-parent-display-name']
          ? {
            user: t['reply-parent-display-name'],
            text: t['reply-parent-msg-body'] || '',
            color: userColorMap.get(t['reply-parent-display-name'].toLowerCase())
          }
          : null;

        const el = buildMessage({
          user: display,
          color,
          html,
          roles: parseRoles(t),
          reply: replyData
        });

        chat.prepend(el);

        while (chat.children.length > CONFIG.maxMessages) {
          chat.lastElementChild?.remove();
        }
      });

      client.connect();

    })();
  </script>
</body>

</html>
