<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
  <title>SadFlower® — Terminal V1</title>

  <style>
    :root {
      --win-blue: #000080;
      --win-border: #808080;
      --win-border-soft: #dfdfdf;

      --glass-bg: rgba(0, 0, 0, .15);
      --glass-blur: 18px;

      --msg-glass-1: rgba(255, 255, 255, 0.068);
      --msg-glass-2: rgba(255, 255, 255, 0.13);

      --meta-h: 18px;
      --meta-font: 10.5px;
      --chev: 7px;

      --broadcaster: #ff2a55;
      --mod: #7aa2f7;
      --vip: #ff8f40;
      --sub: #c792ea;
      --time: #2bbac5;

      --text: #cfcfcf;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      width: 100%;
      height: 100%;
      background: transparent;
      font-family: "JetBrains Mono", Tahoma, "MS Sans Serif", Arial, sans-serif;
      font-size: 16.5px;
      overflow: hidden;
    }

    /* WINDOW */
    .window {
      width: 420px;
      height: 725px;
      backdrop-filter: blur(var(--glass-blur));
      border: 2px solid var(--win-border);
      box-shadow:
        inset 1px 1px 0 var(--win-border-soft),
        inset -1px -1px 0 #404040;
      display: flex;
      flex-direction: column;
    }

    /* TITLE BAR */
    .titlebar {
      height: 52px;
      background: var(--win-blue);
      border-bottom: 2px solid var(--win-border);
      display: flex;
      align-items: center;
      padding: 0 8px;
      flex-shrink: 0;
    }

    .title {
      color: #fff;
      font-size: 13px;
      letter-spacing: .06em;
      font-weight: 600;
    }

    .controls {
      margin-left: auto;
      display: flex;
      gap: 4px;
    }

    .ctrl {
      width: 42px;
      height: 28px;
      display: grid;
      place-items: center;
      border: 1px solid #404040;
      box-shadow:
        inset 1px 1px 0 #dfdfdf,
        inset -1px -1px 0 #606060;
      background: #c0c0c0;
      font-weight: 600;
      user-select: none;
    }

    .ctrl.close {
      background: #e81123;
      color: #fff;
      box-shadow: none;
      border-color: #9e0b16;
    }

    /* CHAT */
    .chat {
      flex: 1;
      padding: 14px;
      display: flex;
      flex-direction: column-reverse;
      gap: 12px;
      overflow: hidden;
    }

    /* MESSAGE */
    .message {
      padding: 10px 12px;
      border-radius: 2px;
      background: linear-gradient(135deg, var(--msg-glass-1), var(--msg-glass-2));
      backdrop-filter: blur(6px);
      border: 1px solid transparent;
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, .12),
        0 2px 6px rgba(0, 0, 0, .35);
      animation: msg-in 220ms steps(3, end);
    }

    .message.reply {
      position: relative;
      padding-left: 16px;
    }

    .message.reply::before {
      content: "";
      position: absolute;
      left: 6px;
      top: 6px;
      bottom: 6px;
      width: 2px;
      background: rgba(255, 255, 255, .4);
    }

    .reply-label {
      font-size: 10px;
      opacity: .7;
      margin-bottom: 2px;
    }

    .reply-box {
      background: #7aa2f72c;
      border: 1px solid rgba(255, 255, 255, 0.18);
      border-left: 4px solid rgba(255, 255, 255, 0.45);
      padding: 6px 8px;
      margin-bottom: 6px;
      font-size: 12px;
      line-height: 1.35;
    }

    .reply-box .reply-user {
      font-weight: 700;
    }

    .reply-box .reply-text {
      color: #cfcfcf;
      opacity: 0.85;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    @keyframes msg-in {
      from {
        opacity: 0;
        transform: translateY(6px);
      }

      to {
        opacity: 1;
        transform: none;
      }
    }

    @keyframes msg-out {
      to {
        opacity: 0;
        transform: scaleY(.6);
      }
    }

    /* EVENT (subs / raids / bits – prêt, pas simulé) */
    .message.event {
      background: #c0c0c0;
      color: #000;
      border-color: #000;
      box-shadow: inset 1px 1px 0 #fff, inset -1px -1px 0 #404040;
      animation: event-in 300ms steps(4, end);
    }

    @keyframes event-in {
      from {
        opacity: 0;
        transform: scale(.95);
      }

      to {
        opacity: 1;
        transform: none;
      }
    }

    /* META */
    .meta {
      display: flex;
      align-items: center;
      height: var(--meta-h);
      margin-bottom: 4px;
    }

    .seg {
      position: relative;
      height: var(--meta-h);
      display: inline-flex;
      align-items: center;
      padding: 0 8px 0 10px;
      font-size: var(--meta-font);
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: .08em;
      color: #0b0f14;
    }

    .seg::after {
      content: "";
      position: absolute;
      right: calc(-1 * var(--chev) + 1px);
      top: 0;
      width: 0;
      height: 0;
      border-top: calc(var(--meta-h)/2) solid transparent;
      border-bottom: calc(var(--meta-h)/2) solid transparent;
      border-left: var(--chev) solid;
    }

    .seg.broadcaster {
      background: var(--broadcaster);
    }

    .seg.broadcaster::after {
      border-left-color: var(--broadcaster);
    }

    .seg.mod {
      background: var(--mod);
    }

    .seg.mod::after {
      border-left-color: var(--mod);
    }

    .seg.vip {
      background: var(--vip);
    }

    .seg.vip::after {
      border-left-color: var(--vip);
    }

    .seg.sub {
      background: var(--sub);
    }

    .seg.sub::after {
      border-left-color: var(--sub);
    }

    .seg.time {
      margin-left: auto;
      background: var(--time);
    }

    .seg.time::after {
      border-left-color: var(--time);
    }

    /* CONTENT */
    .content {
      line-height: 1.6;
      color: var(--text);
      word-wrap: anywhere;
      font-size: 17.5px;
      font-weight: 500;
    }


    .user {
      font-weight: 600;
      margin-right: 6px;
      text-shadow: 0 1px 1px rgba(0, 0, 0, .55);
    }

    .emote {
      height: 1.4em;
      vertical-align: -0.25em;
    }
  </style>
</head>

<body>
  <div class="window">
    <div class="titlebar">
      <div class="title">SADFLOWER — LIVE CHAT</div>
      <div class="controls">
        <div class="ctrl min">–</div>
        <div class="ctrl max">▢</div>
        <div class="ctrl close">✕</div>
      </div>
    </div>
    <div class="chat" id="chat"></div>
  </div>

  <script src="./tmi.min.js"></script>

  <script>
    (() => {

      const CONFIG = {
        channel: 'EnioSadFlower',
        maxMessages: 8,
        lifeMs: 45000,
        ignore: ['streamelements', 'nightbot', 'streamlabs', 'FrankSadFlower']
      };

      const chat = document.getElementById('chat');
      const userColorMap = new Map();
      const emoteMap = new Map();

      const esc = s => {
        const d = document.createElement('div');
        d.textContent = s;
        return d.innerHTML;
      };

      const now = () =>
        new Date().toLocaleTimeString('fr-FR', {
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        });

      function hexToRgba(hex, alpha) {
        if (!hex || !hex.startsWith('#')) return `rgba(255,255,255,${alpha})`;
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      }

      async function loadEmotes(channel) {
        const bttvGlobal = await fetch('https://api.betterttv.net/3/cached/emotes/global').then(r => r.json());
        bttvGlobal.forEach(e => emoteMap.set(e.code, `https://cdn.betterttv.net/emote/${e.id}/2x`));

        const bttvChan = await fetch(`https://api.betterttv.net/3/cached/users/twitch/${channel}`).then(r => r.json()).catch(() => null);
        bttvChan?.channelEmotes?.forEach(e => emoteMap.set(e.code, `https://cdn.betterttv.net/emote/${e.id}/2x`));
        bttvChan?.sharedEmotes?.forEach(e => emoteMap.set(e.code, `https://cdn.betterttv.net/emote/${e.id}/2x`));

        const sevenGlobal = await fetch('https://7tv.io/v3/emote-sets/global').then(r => r.json());
        sevenGlobal.emotes.forEach(e => emoteMap.set(e.name, e.data.host.url + '/2x.webp'));

        const sevenUser = await fetch(`https://7tv.io/v3/users/twitch/${channel}`).then(r => r.json()).catch(() => null);
        sevenUser?.emote_set?.emotes?.forEach(e => emoteMap.set(e.name, e.data.host.url + '/2x.webp'));
      }

      function renderTwitchEmotes(text, emotes) {
        if (!emotes) return esc(text);
        const chars = [...text];
        const map = [];
        for (const id in emotes) {
          emotes[id].forEach(r => {
            const [a, b] = r.split('-').map(Number);
            map.push({ a, b, id });
          });
        }
        map.sort((a, b) => a.a - b.a);
        let out = '', last = 0;
        map.forEach(e => {
          out += esc(chars.slice(last, e.a).join(''));
          out += `<img class="emote" src="https://static-cdn.jtvnw.net/emoticons/v2/${e.id}/default/dark/2.0">`;
          last = e.b + 1;
        });
        out += esc(chars.slice(last).join(''));
        return out;
      }

      function renderThirdPartyEmotes(html) {
        return html.replace(/\b([A-Za-z0-9_]+)\b/g, m => {
          const url = emoteMap.get(m);
          return url ? `<img class="emote" src="${url}">` : m;
        });
      }

      function colorMentions(html) {
        return html.replace(/@([A-Za-z0-9_]{3,25})/g, (m, n) => {
          const c = userColorMap.get(n.toLowerCase());
          return c ? `<span style="color:${c};font-weight:600">@${n}</span>` : m;
        });
      }

      function buildMessage({ user, color, html, roles, reply }) {
        const msg = document.createElement('div');
        msg.className = 'message';
        msg.style.borderColor = hexToRgba(color, 0.3);

        if (reply) {
          const replyBox = document.createElement('div');
          replyBox.className = 'reply-box';

          const replyUserColor =
            reply.color
            || userColorMap.get(reply.user.toLowerCase())
            || '#c792ea';

          replyBox.innerHTML = `
    <div class="reply-user" style="color:${replyUserColor}">
      ↪ Réponse à ${esc(reply.user)}
    </div>
    <div class="reply-text">
      ${esc(reply.text)}
    </div>
  `;

          msg.appendChild(replyBox);
        }
        const meta = document.createElement('div');
        meta.className = 'meta';

        if (roles.broadcaster) meta.innerHTML += `<div class="seg broadcaster">LIVE</div>`;
        if (roles.mod) meta.innerHTML += `<div class="seg mod">MOD</div>`;
        if (roles.vip) meta.innerHTML += `<div class="seg vip">VIP</div>`;
        if (roles.sub) meta.innerHTML += `<div class="seg sub">SUB</div>`;
        meta.innerHTML += `<div class="seg time">${now()}</div>`;

        const content = document.createElement('div');
        content.className = 'content';

        content.innerHTML = `<span class="user" style="color:${color}">${esc(user)}</span>: ${html}`;

        msg.append(meta, content);

        setTimeout(() => msg.style.animation = 'msg-out 180ms forwards', CONFIG.lifeMs - 200);
        setTimeout(() => msg.remove(), CONFIG.lifeMs);

        return msg;
      }

      function parseRoles(tags) {
        return {
          broadcaster: !!tags.badges?.broadcaster,
          mod: !!(tags.badges?.moderator || tags.mod),
          vip: !!tags.badges?.vip,
          sub: !!(tags.badges?.subscriber || tags.subscriber)
        };
      }

      loadEmotes(CONFIG.channel);

      const client = new tmi.Client({
        connection: { secure: true, reconnect: true },
        channels: ['#' + CONFIG.channel.toLowerCase()]
      });

      client.on('message', (c, t, m, self) => {

        if (self) return;
        const login = t.username.toLowerCase();
        if (CONFIG.ignore.includes(login)) return;

        const display = t['display-name'] || login;
        const color = t.color || '#9cdcfe';
        userColorMap.set(display.toLowerCase(), color);

        let html = renderTwitchEmotes(m, t.emotes);
        html = renderThirdPartyEmotes(html);
        html = colorMentions(html);

        const replyData = t['reply-parent-display-name']
          ? {
            user: t['reply-parent-display-name'],
            text: t['reply-parent-msg-body'] || '',
            color: userColorMap.get(t['reply-parent-display-name'].toLowerCase())
          }
          : null;

        const el = buildMessage({
          user: display,
          color,
          html,
          roles: parseRoles(t),
          reply: replyData
        });


        chat.prepend(el);

        while (chat.children.length > CONFIG.maxMessages) {
          chat.lastElementChild?.remove();
        }
      });

      client.connect();

    })();
  </script>
</body>

</html>